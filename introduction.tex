\section{Introduction}
\label{sec:introduction}

Multithreaded programming has become very popular with the multi-core
revolution that spread in the last two decades.
%
This has aroused, in the High Performance Computing (HPC) world, to adopt
on-node parallelism to a greater degree in large software applications
development in order to guarantee the future required performance and power
budgets.
%
In support of this argument, HPC is undergoing an explosion in
computing capabilities, which is confirmed by the work-in-progress of the
next-generation of supercomputer projects in the main national research
facilities of the country~\cite{sierra, summit, trinity}.
%
Multithreaded programming is achieved through different programming models
(e.g. Pthreads), however the predominant paradigm of choice in HPC is
OpenMP~\cite{ompdoc}, which guarantees portability and ease of use.
%
In fact, we are collaborating with computational scientists at Lawrence
Livermore National Laboratory (LLNL), one of the world's largest computing
facilities, where the main task is the porting of critical multiphysics
application~\cite{llnl-apps} to OpenMP.

OpenMP is paramount to portable shared memory parallel programming - yet,
porting large HPC applications to OpenMP is error-prone.
%
The correctness of these applications is crucial to the reliability of the
simulations pertaining to many real world phenomena of fundamental importance
such as modeling of nuclear explosions, weather simulations, hydrodynamics
modeling, etc.
%
The most common errors in OpenMP applications are data
races~\cite{sus_common_2008}.
%
Data races are often hard to find with traditional debugging methods.
%
Precise checking tools to detect these kinds of errors are needed now more
than ever.
%
While data race is a well-known problem and many Pthreads data race detection
tools have been proposed over the past twenty years, none or just a few of
them are actually able to analyze OpenMP programs.
%
OpenMP programs are generally translated by the compiler into Pthreads
programs,

Data race detection research has been focused both on static and dynamic
analysis techniques.
%                                                 
Static analysis techniques allow to reason about all the inputs of the program
and the interleavings of the threads, and they are fairly scalable and fast
since no runtime overhead is generated.
%
However, the lack of information that exists only at runtime makes these
techniques very imprecise, in fact they often miss races and report many false
positives.
%
While runtime techniques are very precise, in general they do not
report any false positives and reports the races in the branches of the
programs that are actually executed if any.
%
On the other hand dynamic analysis for data race detection is known to
generate a very high runtime and memory overhead due to the operations it
needs to perform and the states it needs to maintain to report the races.


\begin{itemize}
  \item Importance of runtime and memory overhead reduction in data race
    detection
  \item HPC --> very large program, often unfeasible to verify with
    existing techniques
    \begin{itemize}
    \item runtime too long
    \item large amount of memory required --> not able to finish the
      runtime check
    \end{itemize}
  \item Real-cases: see HYDRA
  \item Races and benign races
  \item Goal of the dissertation: data race detector tool, low overhead, etc.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% eval: (flyspell-mode 1)
%%% TeX-master: "root.tex"
%%% End:
